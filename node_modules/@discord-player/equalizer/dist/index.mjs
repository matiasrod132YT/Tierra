var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/biquad/Coefficients.ts
var FilterType = /* @__PURE__ */ ((FilterType3) => {
  FilterType3[FilterType3["SinglePoleLowPassApprox"] = 0] = "SinglePoleLowPassApprox";
  FilterType3[FilterType3["SinglePoleLowPass"] = 1] = "SinglePoleLowPass";
  FilterType3[FilterType3["LowPass"] = 2] = "LowPass";
  FilterType3[FilterType3["HighPass"] = 3] = "HighPass";
  FilterType3[FilterType3["BandPass"] = 4] = "BandPass";
  FilterType3[FilterType3["Notch"] = 5] = "Notch";
  FilterType3[FilterType3["AllPass"] = 6] = "AllPass";
  FilterType3[FilterType3["LowShelf"] = 7] = "LowShelf";
  FilterType3[FilterType3["HighShelf"] = 8] = "HighShelf";
  FilterType3[FilterType3["PeakingEQ"] = 9] = "PeakingEQ";
  return FilterType3;
})(FilterType || {});
var Q_BUTTERWORTH = Math.SQRT1_2;
var Coefficients = class {
  constructor(data) {
    this.a1 = 0;
    this.a2 = 0;
    this.b0 = 0;
    this.b1 = 0;
    this.b2 = 0;
    if (data) {
      this.a1 = data.a1;
      this.a2 = data.a2;
      this.b0 = data.b0;
      this.b1 = data.b1;
      this.b2 = data.b2;
    }
  }
  static from(filter, samplingFreq, cutoffFreq, Q, dbGain = 0) {
    if (2 * cutoffFreq > samplingFreq) {
      throw new Error(`Cutoff frequency is too big!`);
    }
    if (Q < 0) {
      throw new Error(`Q may not be negative`);
    }
    const omega = 2 * Math.PI * cutoffFreq / samplingFreq;
    switch (filter) {
      case 0 /* SinglePoleLowPassApprox */: {
        const alpha = omega / (omega + 1);
        return new Coefficients({
          a1: alpha - 1,
          a2: 0,
          b0: alpha,
          b1: 0,
          b2: 0
        });
      }
      case 1 /* SinglePoleLowPass */: {
        const omega_t = Math.tan(omega / 2);
        const a0 = 1 + omega_t;
        return new Coefficients({
          a1: (omega_t - 1) / a0,
          a2: 0,
          b0: omega_t / a0,
          b1: omega_t / a0,
          b2: 0
        });
      }
      case 2 /* LowPass */: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = (1 - omega_c) * 0.5;
        const b1 = 1 - omega_c;
        const b2 = (1 - omega_c) * 0.5;
        const a0 = 1 + alpha;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha;
        const div = 1 / a0;
        return new Coefficients({
          a1: a1 * div,
          a2: a2 * div,
          b0: b0 * div,
          b1: b1 * div,
          b2: b2 * div
        });
      }
      case 3 /* HighPass */: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = (1 + omega_c) * 0.5;
        const b1 = -(1 + omega_c);
        const b2 = (1 + omega_c) * 0.5;
        const a0 = 1 + alpha;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha;
        const div = 1 / a0;
        return new Coefficients({
          a1: a1 * div,
          a2: a2 * div,
          b0: b0 * div,
          b1: b1 * div,
          b2: b2 * div
        });
      }
      case 5 /* Notch */: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = 1;
        const b1 = -2 * omega_c;
        const b2 = 1;
        const a0 = 1 + alpha;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha;
        const div = 1 / a0;
        return new Coefficients({
          a1: a1 * div,
          a2: a2 * div,
          b0: b0 * div,
          b1: b1 * div,
          b2: b2 * div
        });
      }
      case 4 /* BandPass */: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        let b0 = omega_s / 2;
        let b1 = 0;
        let b2 = -(omega_s / 2);
        let a0 = 1 + alpha;
        let a1 = -2 * omega_c;
        let a2 = 1 - alpha;
        let div = 1 / a0;
        return new Coefficients({
          a1: a1 * div,
          a2: a2 * div,
          b0: b0 * div,
          b1: b1 * div,
          b2: b2 * div
        });
      }
      case 6 /* AllPass */: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        let b0 = 1 - alpha;
        let b1 = -2 * omega_c;
        let b2 = 1 + alpha;
        let a0 = 1 + alpha;
        let a1 = -2 * omega_c;
        let a2 = 1 - alpha;
        return new Coefficients({
          a1: a1 / a0,
          a2: a2 / a0,
          b0: b0 / a0,
          b1: b1 / a0,
          b2: b2 / a0
        });
      }
      case 7 /* LowShelf */: {
        let a = Math.pow(10, dbGain / 40);
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        let b0 = a * (a + 1 - (a - 1) * omega_c + 2 * alpha * Math.sqrt(a));
        let b1 = 2 * a * (a - 1 - (a + 1) * omega_c);
        let b2 = a * (a + 1 - (a - 1) * omega_c - 2 * alpha * Math.sqrt(a));
        let a0 = a + 1 + (a - 1) * omega_c + 2 * alpha * Math.sqrt(a);
        let a1 = -2 * (a - 1 + (a + 1) * omega_c);
        let a2 = a + 1 + (a - 1) * omega_c - 2 * alpha * Math.sqrt(a);
        return new Coefficients({
          a1: a1 / a0,
          a2: a2 / a0,
          b0: b0 / a0,
          b1: b1 / a0,
          b2: b2 / a0
        });
      }
      case 8 /* HighShelf */: {
        let a = Math.pow(10, dbGain / 40);
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        let b0 = a * (a + 1 + (a - 1) * omega_c + 2 * alpha * Math.sqrt(a));
        let b1 = -2 * a * (a - 1 + (a + 1) * omega_c);
        let b2 = a * (a + 1 + (a - 1) * omega_c - 2 * alpha * Math.sqrt(a));
        let a0 = a + 1 - (a - 1) * omega_c + 2 * alpha * Math.sqrt(a);
        let a1 = 2 * (a - 1 - (a + 1) * omega_c);
        let a2 = a + 1 - (a - 1) * omega_c - 2 * alpha * Math.sqrt(a);
        return new Coefficients({
          a1: a1 / a0,
          a2: a2 / a0,
          b0: b0 / a0,
          b1: b1 / a0,
          b2: b2 / a0
        });
      }
      case 9 /* PeakingEQ */: {
        let a = Math.pow(10, dbGain / 40);
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        let b0 = 1 + alpha * a;
        let b1 = -2 * omega_c;
        let b2 = 1 - alpha * a;
        let a0 = 1 + alpha / a;
        let a1 = -2 * omega_c;
        let a2 = 1 - alpha / a;
        return new Coefficients({
          a1: a1 / a0,
          a2: a2 / a0,
          b0: b0 / a0,
          b1: b1 / a0,
          b2: b2 / a0
        });
      }
      default:
        throw new TypeError("Invalid filter type");
    }
  }
};
__name(Coefficients, "Coefficients");

// src/biquad/Biquad.ts
var BiquadFilter = class {
  constructor(coefficients) {
    this.coefficients = coefficients;
    this.x1 = 0;
    this.x2 = 0;
    this.y1 = 0;
    this.y2 = 0;
    this.s1 = 0;
    this.s2 = 0;
  }
  setFilter(filter, options) {
    const coefficients = Coefficients.from(filter, options.fs, options.f0, options.Q, options.gain);
    this.update(coefficients);
  }
  update(coefficients) {
    this.coefficients = coefficients;
  }
  replace(coefficients) {
    this.coefficients = coefficients;
  }
  reset() {
    this.x1 = 0;
    this.x2 = 0;
    this.y1 = 0;
    this.y2 = 0;
    this.s1 = 0;
    this.s2 = 0;
  }
  run(input) {
    const { a1, a2, b0, b1, b2 } = this.coefficients;
    const out = b0 * input + b1 * this.x1 + b2 * this.x2 - a1 * this.y1 - a2 * this.y2;
    this.x2 = this.x1;
    this.x1 = input;
    this.y2 = this.y1;
    this.y1 = out;
    return out;
  }
  runTransposed(input) {
    const { a1, a2, b0, b1, b2 } = this.coefficients;
    const out = this.s1 + b0 * input;
    this.s1 = this.s2 + b1 * input - a1 * out;
    this.s2 = b2 * input - a2 * out;
    return out;
  }
};
__name(BiquadFilter, "BiquadFilter");

// src/equalizer/ChannelProcessor.ts
var ChannelProcessor = class {
  constructor(bandMultipliers) {
    this._extremum = Math.pow(2, 16 - 1);
    this.history = new Array(Equalizer.BAND_COUNT * 6).fill(0);
    this.bandMultipliers = bandMultipliers;
    this.current = 0;
    this.m1 = 2;
    this.m2 = 1;
  }
  process(samples) {
    const endIndex = Math.floor(samples.length / 2) * 2;
    for (let sampleIndex = 0; sampleIndex < endIndex; sampleIndex += 2) {
      const sample = samples.readInt16LE(sampleIndex);
      let result = sample * 0.25;
      for (let bandIndex = 0; bandIndex < Equalizer.BAND_COUNT; bandIndex++) {
        const x = bandIndex * 6;
        const y = x + 3;
        const coefficients = Equalizer.Coefficients48000[bandIndex];
        const bandResult = coefficients.alpha * (sample - this.history[x + this.m2]) + coefficients.gamma * this.history[y + this.m1] - coefficients.beta * this.history[y + this.m2];
        this.history[x + this.current] = sample;
        this.history[y + this.current] = bandResult;
        result += bandResult * this.bandMultipliers[bandIndex];
      }
      const val = Math.min(this._extremum - 1, Math.max(-this._extremum, result * 4));
      samples.writeInt16LE(val, sampleIndex);
      if (++this.current === 3) {
        this.current = 0;
      }
      if (++this.m1 === 3) {
        this.m1 = 0;
      }
      if (++this.m2 === 3) {
        this.m2 = 0;
      }
    }
    return samples;
  }
  reset() {
    this.history.fill(0);
  }
};
__name(ChannelProcessor, "ChannelProcessor");

// src/equalizer/Coefficients.ts
var EqualizerCoefficients = class {
  constructor(beta, alpha, gamma) {
    this.beta = beta;
    this.alpha = alpha;
    this.gamma = gamma;
  }
  setBeta(v) {
    this.beta = v;
  }
  setAlpha(v) {
    this.alpha = v;
  }
  setGamma(v) {
    this.gamma = v;
  }
  toJSON() {
    const { alpha, beta, gamma } = this;
    return { alpha, beta, gamma };
  }
};
__name(EqualizerCoefficients, "EqualizerCoefficients");

// src/equalizer/EqualizerConfiguration.ts
var EqualizerConfiguration = class {
  constructor(bandMultipliers) {
    this.bandMultipliers = bandMultipliers;
  }
  setGain(band, value) {
    if (this.isValidBand(band)) {
      this.bandMultipliers[band] = Math.max(Math.min(value, 1), -0.25);
    }
  }
  getGain(band) {
    if (this.isValidBand(band)) {
      return this.bandMultipliers[band];
    } else {
      return 0;
    }
  }
  isValidBand(band) {
    return band >= 0 && band < this.bandMultipliers.length;
  }
};
__name(EqualizerConfiguration, "EqualizerConfiguration");

// src/equalizer/Equalizer.ts
var Equalizer = class extends EqualizerConfiguration {
  constructor(channelCount, bandMultipliers) {
    super(bandMultipliers);
    this.channels = [];
    this.channelCount = channelCount;
    this.channels = this.createChannelProcessor();
  }
  createChannelProcessor() {
    return Array.from({ length: this.channelCount }, () => {
      return new ChannelProcessor(this.bandMultipliers);
    });
  }
  process(input) {
    return this.channels.map((c, i) => {
      const inp = input[i];
      return c.process(inp);
    });
  }
};
__name(Equalizer, "Equalizer");
Equalizer.BAND_COUNT = 15;
Equalizer.SAMPLE_RATE = 48e3;
Equalizer.Coefficients48000 = [
  new EqualizerCoefficients(0.99847546664, 76226668143e-14, 1.9984647656),
  new EqualizerCoefficients(0.99756184654, 0.0012190767289, 1.9975344645),
  new EqualizerCoefficients(0.99616261379, 0.0019186931041, 1.9960947369),
  new EqualizerCoefficients(0.99391578543, 0.0030421072865, 1.9937449618),
  new EqualizerCoefficients(0.99028307215, 0.0048584639242, 1.9898465702),
  new EqualizerCoefficients(0.98485897264, 0.0075705136795, 1.9837962543),
  new EqualizerCoefficients(0.97588512657, 0.012057436715, 1.9731772447),
  new EqualizerCoefficients(0.96228521814, 0.018857390928, 1.9556164694),
  new EqualizerCoefficients(0.94080933132, 0.029595334338, 1.9242054384),
  new EqualizerCoefficients(0.90702059196, 0.046489704022, 1.8653476166),
  new EqualizerCoefficients(0.85868004289, 0.070659978553, 1.7600401337),
  new EqualizerCoefficients(0.78409610788, 0.10795194606, 1.5450725522),
  new EqualizerCoefficients(0.68332861002, 0.15833569499, 1.1426447155),
  new EqualizerCoefficients(0.55267518228, 0.22366240886, 0.40186190803),
  new EqualizerCoefficients(0.41811888447, 0.29094055777, -0.70905944223)
];

// src/equalizer/EqualizerStream.ts
import { Transform } from "stream";
var EqualizerStream = class extends Transform {
  constructor(options) {
    super(options);
    this.disabled = false;
    this.bandMultipliers = new Array(Equalizer.BAND_COUNT).fill(0);
    options = Object.assign({}, {
      bandMultiplier: [],
      channels: 1,
      disabled: false
    }, options || {});
    if (options.disabled)
      this.disabled = !!options.disabled;
    this.equalizer = new Equalizer(options.channels || 1, this.bandMultipliers);
    if (Array.isArray(options.bandMultiplier))
      this._processBands(options.bandMultiplier);
  }
  _processBands(multiplier) {
    for (const mul of multiplier) {
      if (mul.band > Equalizer.BAND_COUNT - 1 || mul.band < 0)
        throw new RangeError(`Band value out of range. Expected >0 & <${Equalizer.BAND_COUNT - 1}, received "${mul.band}"`);
      this.equalizer.setGain(mul.band, mul.gain);
    }
  }
  disable() {
    this.disabled = true;
  }
  enable() {
    this.disabled = false;
  }
  toggle() {
    this.disabled = !this.disabled;
  }
  _transform(chunk, encoding, callback) {
    if (this.disabled) {
      this.push(chunk);
      return callback();
    }
    this.equalizer.process([chunk]);
    this.push(chunk);
    return callback();
  }
  getEQ() {
    return this.bandMultipliers.map((m, i) => ({
      band: i,
      gain: m
    }));
  }
  setEQ(bands) {
    this._processBands(bands);
  }
  resetEQ() {
    this._processBands(
      Array.from(
        {
          length: Equalizer.BAND_COUNT
        },
        (_, i) => ({
          band: i,
          gain: 0
        })
      )
    );
  }
};
__name(EqualizerStream, "EqualizerStream");

// src/utils/Frequency.ts
var Frequency = class {
  constructor(__val) {
    this.__val = __val;
    if (typeof __val !== "number" || isNaN(__val) || __val === Infinity)
      throw new TypeError("Frequency value must be a number");
    if (this.__val < 0)
      throw new Error(`Frequency value cannot be negative (${__val})`);
  }
  khz() {
    return this.__val * 1e3;
  }
  mhz() {
    return this.__val * 1e6;
  }
  hz() {
    return this.__val;
  }
  dt() {
    return 1 / this.__val;
  }
  valueOf() {
    return this.__val;
  }
  toString() {
    return `${this.__val}Hz`;
  }
  toJSON() {
    return this.toString();
  }
};
__name(Frequency, "Frequency");
export {
  BiquadFilter,
  ChannelProcessor,
  Coefficients,
  Equalizer,
  EqualizerCoefficients,
  EqualizerConfiguration,
  EqualizerStream,
  FilterType,
  Frequency,
  Q_BUTTERWORTH
};
