"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildCommand = void 0;
const tslib_1 = require("tslib");
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = require("path");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const toml_1 = tslib_1.__importDefault(require("toml"));
const consts_1 = require("./consts");
const debug_1 = require("./debug");
const utils_1 = require("./utils");
const debug = debug_1.debugFactory('build');
class BuildCommand extends clipanion_1.Command {
    constructor() {
        super(...arguments);
        this.isRelease = false;
        this.isMusl = false;
        this.targetTripleDir = '';
        this.target = '.';
    }
    execute() {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { binaryName } = consts_1.getNapiConfig(this.configFileName);
            let dylibName = this.cargoName;
            if (!dylibName) {
                let tomlContentString;
                let tomlContent;
                try {
                    debug('Start read toml');
                    tomlContentString = yield utils_1.readFileAsync(path_1.join(process.cwd(), 'Cargo.toml'), 'utf-8');
                }
                catch (_b) {
                    throw new TypeError(`Could not find Cargo.toml in ${process.cwd()}`);
                }
                try {
                    debug('Start parse toml');
                    tomlContent = toml_1.default.parse(tomlContentString);
                }
                catch (_c) {
                    throw new TypeError('Could not parse the Cargo.toml');
                }
                if ((_a = tomlContent.package) === null || _a === void 0 ? void 0 : _a.name) {
                    dylibName = tomlContent.package.name.replace(/-/g, '_');
                }
                else {
                    throw new TypeError('No package.name field in Cargo.toml');
                }
            }
            debug(`Dylib name: ${chalk_1.default.greenBright(dylibName)}`);
            const platform = os_1.default.platform();
            let libExt;
            debug(`Platform: ${chalk_1.default.greenBright(platform)}`);
            // Platform based massaging for build commands
            switch (platform) {
                case 'darwin':
                    libExt = '.dylib';
                    dylibName = `lib${dylibName}`;
                    break;
                case 'win32':
                    libExt = '.dll';
                    break;
                case 'linux':
                case 'freebsd':
                    dylibName = `lib${dylibName}`;
                    libExt = '.so';
                    break;
                default:
                    throw new TypeError('Operating system not currently supported or recognized by the build script');
            }
            const targetDir = path_1.join(this.targetTripleDir, this.isRelease ? 'release' : 'debug');
            if (this.isMusl && !this.appendPlatformToFilename) {
                throw new TypeError(`Musl flag must be used with platform flag`);
            }
            const platformName = this.appendPlatformToFilename
                ? !this.isMusl
                    ? `.${platform}`
                    : `.${platform}-musl`
                : '';
            debug(`Platform name: ${platformName || chalk_1.default.green('[Empty]')}, musl: ${chalk_1.default.greenBright(this.isMusl)}`);
            let distModulePath = this.target
                ? path_1.join(this.target, `${binaryName}${platformName}.node`)
                : path_1.join('target', targetDir, `${binaryName}${platformName}.node`);
            const parsedDist = path_1.parse(distModulePath);
            if (!parsedDist.ext) {
                distModulePath = `${distModulePath}${platformName}.node`;
            }
            const dir = yield findUp();
            if (!dir) {
                throw new TypeError('No target dir found');
            }
            const sourcePath = path_1.join(dir, 'target', targetDir, `${dylibName}${libExt}`);
            debug(`Read [${chalk_1.default.yellowBright(sourcePath)}] content`);
            const dylibContent = yield utils_1.readFileAsync(sourcePath);
            debug(`Write binary content to [${chalk_1.default.yellowBright(distModulePath)}]`);
            yield utils_1.writeFileAsync(distModulePath, dylibContent);
        });
    }
}
BuildCommand.usage = clipanion_1.Command.Usage({
    description: 'Copy native module into specified dir',
});
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--platform`),
    tslib_1.__metadata("design:type", Boolean)
], BuildCommand.prototype, "appendPlatformToFilename", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--release`),
    tslib_1.__metadata("design:type", Object)
], BuildCommand.prototype, "isRelease", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean('--musl'),
    tslib_1.__metadata("design:type", Object)
], BuildCommand.prototype, "isMusl", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String('--config,-c'),
    tslib_1.__metadata("design:type", String)
], BuildCommand.prototype, "configFileName", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String('--cargo-name'),
    tslib_1.__metadata("design:type", String)
], BuildCommand.prototype, "cargoName", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String('--target-triple'),
    tslib_1.__metadata("design:type", Object)
], BuildCommand.prototype, "targetTripleDir", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String({
        required: false,
    }),
    tslib_1.__metadata("design:type", Object)
], BuildCommand.prototype, "target", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path('build'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", Promise)
], BuildCommand.prototype, "execute", null);
exports.BuildCommand = BuildCommand;
function findUp(dir = process.cwd()) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const dist = path_1.join(dir, 'target');
        if (yield utils_1.existsAsync(dist)) {
            return dir;
        }
        const dirs = dir.split(path_1.sep);
        if (dirs.length < 2) {
            return null;
        }
        dirs.pop();
        return findUp(dirs.join(path_1.sep));
    });
}
//# sourceMappingURL=build.js.map