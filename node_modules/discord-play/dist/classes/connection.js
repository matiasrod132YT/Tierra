"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisPlayConnection = void 0;
const voice_1 = require("@discordjs/voice");
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const util_1 = require("util");
const wait = (0, util_1.promisify)(setTimeout);
/**
 * The voice connection class of `discord-play`. The bot joins the input voice state
 * as soon as an instance is created.
 */
class DisPlayConnection extends tiny_typed_emitter_1.TypedEmitter {
    /**
     * Joins the voice channel on instance creation.
     * @param voice The voice state of a member.
     */
    constructor(voice) {
        super();
        this.readyLock = false;
        if (!voice.channel)
            throw new Error("member voice channel not found");
        this.connection = (0, voice_1.joinVoiceChannel)({ channelId: voice.channel.id, guildId: voice.guild.id, adapterCreator: voice.guild.voiceAdapterCreator });
        this.oldVoiceID = this.connection.joinConfig.channelId;
        this.connection.on('stateChange', async (oldState, newState) => {
            switch (newState.status) {
                case voice_1.VoiceConnectionStatus.Ready:
                    this.emit('voiceConnectionCreate', this.oldVoiceID);
                    break;
                case voice_1.VoiceConnectionStatus.Destroyed:
                    this.emit('voiceConnectionDestroy', this.oldVoiceID);
                    break;
                case voice_1.VoiceConnectionStatus.Disconnected:
                    if (newState.reason === voice_1.VoiceConnectionDisconnectReason.WebSocketClose && newState.closeCode === 4014) {
                        (0, voice_1.entersState)(this.connection, voice_1.VoiceConnectionStatus.Connecting, 3000)
                            .then(() => {
                            this.emit('voiceConnectionMove', this.oldVoiceID, this.connection.joinConfig.channelId);
                            this.oldVoiceID = this.connection.joinConfig.channelId;
                        })
                            .catch(error => void this.emit('voiceConnectionKick', this.connection.joinConfig.channelId));
                    }
                    else if (this.connection.rejoinAttempts < 5) {
                        await wait(++this.connection.rejoinAttempts * 3000);
                        this.connection.rejoin();
                    }
                    else {
                        this.connection.destroy();
                        this.emit('error', new Error("connection_error"));
                    }
                    break;
                case voice_1.VoiceConnectionStatus.Connecting:
                case voice_1.VoiceConnectionStatus.Signalling:
                    if (this.readyLock)
                        return;
                    this.readyLock = true;
                    await (0, voice_1.entersState)(this.connection, voice_1.VoiceConnectionStatus.Ready, 20000)
                        .then(() => this.readyLock = false)
                        .catch(error => {
                        if (this.connection.state.status !== voice_1.VoiceConnectionStatus.Destroyed) {
                            this.connection.destroy();
                            this.emit('error', new Error("connection_error"));
                        }
                        this.readyLock = false;
                    });
                    break;
            }
        });
    }
    /**
     * The {@link AudioPlayer} attached to the voice connection (if any).
     */
    get player() {
        var _a, _b;
        return (_b = (_a = this.connection.state) === null || _a === void 0 ? void 0 : _a.subscription) === null || _b === void 0 ? void 0 : _b.player;
    }
    /**
     * Toggle self-deafening of the bot.
     * @returns `true` if self-deafened, otherwise `false` i.e. self-undeafened.
     */
    toggleDeafen() {
        const flag = this.connection.joinConfig.selfDeaf;
        this.connection.joinConfig.selfDeaf = !flag;
        this.connection.rejoin(this.connection.joinConfig);
        this.emit('selfDeafen', !flag);
        return !flag;
    }
    /**
     * Toggle self-muting of the bot.
     * @returns `true` if self-muted, otherwise `false` i.e. self-unmuted.
     */
    toggleMute() {
        const flag = this.connection.joinConfig.selfMute;
        this.connection.joinConfig.selfMute = !flag;
        this.connection.rejoin(this.connection.joinConfig);
        this.emit('selfMute', !flag);
        return !flag;
    }
    /**
     * Destroys the voice connection, making it unable to be reused again.
     */
    destroy() {
        this.connection.destroy();
    }
}
exports.DisPlayConnection = DisPlayConnection;
//# sourceMappingURL=connection.js.map