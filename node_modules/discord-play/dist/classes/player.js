"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisPlayPlayer = void 0;
const voice_1 = require("@discordjs/voice");
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
/**
 * The audio player class of `discord-play`.
 *
 * Must be created only after a voice connection is
 * established, either through a {@link DisPlayConnection} instance or the @discordjs/voice
 * `joinVoiceChannel` function.
 */
class DisPlayPlayer extends tiny_typed_emitter_1.TypedEmitter {
    /**
     * Attaches logic to the audio player and binds it to the voice connection.
     * @param guildId - The ID of the guild where the voice connection is established.
     */
    constructor(guildId) {
        super();
        /**
         * The {@link AudioPlayer} instance from @discordjs/voice.
         */
        this.player = (0, voice_1.createAudioPlayer)();
        /**
         * Stores previous volume amount before muting the player, which can be restored back
         * when unmuting the player.
         */
        this.volumeCache = null;
        const connection = (0, voice_1.getVoiceConnection)(guildId);
        if (!connection)
            throw new Error("no active voice connection found in specified guild");
        this.player.on('stateChange', (oldState, newState) => {
            switch (newState.status) {
                case voice_1.AudioPlayerStatus.Buffering:
                    this.emit('audioPlayerBuffer', oldState, newState);
                    break;
                case voice_1.AudioPlayerStatus.Idle:
                    this.emit('audioPlayerFinish', oldState, newState);
                    break;
                case voice_1.AudioPlayerStatus.Paused:
                    this.emit('audioPlayerPause', oldState, newState);
                    break;
                case voice_1.AudioPlayerStatus.AutoPaused:
                    this.emit('audioPlayerAutoPause', oldState, newState);
                    break;
                case voice_1.AudioPlayerStatus.Playing:
                    switch (oldState.status) {
                        case voice_1.AudioPlayerStatus.Buffering:
                            this.emit('audioPlayerStart', oldState, newState);
                            break;
                        case voice_1.AudioPlayerStatus.Paused:
                            this.emit('audioPlayerResume', oldState, newState);
                            break;
                        default: break;
                    }
                    break;
                default: break;
            }
        });
        this.player.on('error', error => void this.emit('error', error));
        try {
            connection.subscribe(this.player);
        }
        catch (error) {
            this.emit('error', error);
        }
    }
    play(source, options) {
        var _a, _b;
        try {
            if (source instanceof voice_1.AudioResource) {
                this.player.play(source);
            }
            else {
                const resource = (0, voice_1.createAudioResource)(source, {
                    inputType: (_a = options === null || options === void 0 ? void 0 : options.streamType) !== null && _a !== void 0 ? _a : voice_1.StreamType.Arbitrary,
                    inlineVolume: (options === null || options === void 0 ? void 0 : options.volume) ? true : false
                });
                if (options === null || options === void 0 ? void 0 : options.volume)
                    (_b = resource.volume) === null || _b === void 0 ? void 0 : _b.setVolume(options.volume);
                this.player.play(resource);
            }
        }
        catch (error) {
            this.emit('error', error);
        }
    }
    /**
     * Stops the audio player and destroys any underlying resource.
     * @returns `true` if the player will come to a stop, otherwise `false`.
     */
    stop() {
        return this.player.stop();
    }
    /**
     * Pauses/unpauses the audio player.
     * @returns `true` if player is paused, else `false` i.e. unpaused.
     */
    togglePause() {
        var _a;
        switch ((_a = this.player.state) === null || _a === void 0 ? void 0 : _a.status) {
            case voice_1.AudioPlayerStatus.Playing: return this.player.pause(true);
            case voice_1.AudioPlayerStatus.Paused: return !this.player.unpause();
            default: return false;
        }
    }
    /**
     * Returns the amount of volume in percentage (0 to 100) of the player resource.
     * @remarks
     * Returns percentage of volume else undefined if player doesn't have any underlying resource
     * or resource doesn't have inline volume enabled (has 100% volume).
     */
    get volume() {
        var _a;
        if (this.player.state.status !== voice_1.AudioPlayerStatus.Idle) {
            const vol = (_a = this.player.state.resource.volume) === null || _a === void 0 ? void 0 : _a.volume;
            return vol ? vol * 100 : vol;
        }
        return undefined;
    }
    /**
     * Changes volume of the underlying resource of the player.
     * @param volume - Percentage of volume to set (0 to 100).
     * @returns `true` if volume is changed successfully, otherwise `false`.
     *
     * @remarks
     * Works only when inline volume of resource was enabled.
     */
    setVolume(volume) {
        if (this.isVolumeChangeable()) {
            this.player.state.resource.volume.setVolume(volume / 100);
            return true;
        }
        return false;
    }
    /**
     * Mutes/Unmutes the audio player.
     * @returns `true` if player was muted, otherwise `false`.
     *
     * @remarks
     * Requires the currently playing audio resource to have inline volume enabled.
     *
     * @throws Error if resource doesn't have inline volume enabled.
     */
    toggleMute() {
        var _a;
        if (!this.isVolumeChangeable())
            throw new Error("Unable to detect resource with inline volume enabled.");
        if (!this.volumeCache) {
            this.volumeCache = (_a = this.volume) !== null && _a !== void 0 ? _a : null;
            this.setVolume(0);
            return true;
        }
        else {
            this.setVolume(this.volumeCache);
            this.volumeCache = null;
            return false;
        }
    }
    /**
     * To detect if currently underlying resource (if any) has inline volume enabled or not.
     * @returns `true` if inline volume is enabled, otherwise `false`.
     */
    isVolumeChangeable() {
        if (this.player.state.status !== voice_1.AudioPlayerStatus.Idle) {
            return this.player.state.resource.volume ? true : false;
        }
        return false;
    }
}
exports.DisPlayPlayer = DisPlayPlayer;
//# sourceMappingURL=player.js.map